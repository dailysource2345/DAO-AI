/**
 * ROFL Remote Attestation Module
 * 
 * This module generates cryptographic attestations proving that computation
 * occurred inside a genuine ROFL TEE (Trusted Execution Environment) enclave.
 * 
 * ATTESTATION INCLUDES:
 * - Enclave measurement (hash of the enclave code)
 * - Input hash (proves what data was processed)
 * - Output hash (proves what results were computed)
 * - Timestamp (when computation occurred)
 * - Signature (cryptographic proof from enclave)
 * 
 * IMPORTANT: DEVELOPMENT VS PRODUCTION MODE
 * ==========================================
 * - Development mode (ROFL_MODE != 'enclave'): Uses simulated attestation
 *   with locally generated signatures for testing purposes.
 * - Production mode (ROFL_MODE == 'enclave'): Uses actual TEE hardware
 *   signing keys provided by the Oasis ROFL runtime. The attestation
 *   is generated by the TEE hardware and can be verified against
 *   Intel SGX/TDX attestation services.
 * 
 * In production, the ROFL_SIGNING_KEY is provided by the TEE runtime
 * and is hardware-protected. The backend must verify attestations
 * against the trusted enclave IDs and app hashes configured in
 * ROFL_TRUSTED_ENCLAVE_IDS and ROFL_TRUSTED_APP_HASHES.
 * 
 * @module attestation
 */

import crypto from 'crypto';

const IS_PRODUCTION = process.env.ROFL_MODE === 'enclave';

// Simulated enclave identity (in production, derived from TEE hardware)
const ENCLAVE_IDENTITY = {
  enclave_id: process.env.ROFL_ENCLAVE_ID || `rofl-enclave-${generateEnclaveId()}`,
  app_hash: process.env.ROFL_APP_HASH || generateAppHash(),
  tee_type: process.env.ROFL_TEE_TYPE || 'sgx',
  version: '1.0.0'
};

/**
 * Generate a deterministic enclave ID based on app configuration
 */
function generateEnclaveId() {
  const seed = 'daoai-reputation-rofl-v1';
  return crypto.createHash('sha256').update(seed).digest('hex').substring(0, 16);
}

/**
 * Generate app hash (measurement of the enclave code)
 */
function generateAppHash() {
  const appContent = 'daoai-reputation-rofl-app-v1.0.0';
  return crypto.createHash('sha256').update(appContent).digest('hex');
}

/**
 * Get the current enclave identity
 * 
 * @returns {Object} Enclave identity information
 */
export function getEnclaveIdentity() {
  return {
    ...ENCLAVE_IDENTITY,
    mode: process.env.ROFL_MODE || 'development',
    started_at: new Date().toISOString()
  };
}

/**
 * Generate a ROFL remote attestation for a computation
 * 
 * @param {Object} computationData - Data about the computation performed
 * @returns {Object} Remote attestation object
 */
export async function generateAttestation(computationData) {
  const timestamp = new Date().toISOString();
  
  // Create attestation payload
  const attestationPayload = {
    // Enclave identity
    enclave: {
      id: ENCLAVE_IDENTITY.enclave_id,
      app_hash: ENCLAVE_IDENTITY.app_hash,
      tee_type: ENCLAVE_IDENTITY.tee_type,
      version: ENCLAVE_IDENTITY.version
    },
    
    // Computation metadata
    computation: {
      user_id: computationData.daoai_user_id,
      wallet_hash: computationData.wallet_address_hash,
      reputation_score: computationData.reputation_score,
      confidence_score: computationData.confidence_score,
      duration_ms: computationData.computation_time_ms
    },
    
    // Timestamps
    timestamp,
    nonce: generateNonce()
  };

  // Generate deterministic attestation hash
  const attestationHash = generateAttestationHash(attestationPayload);
  
  // Generate signature (in production, this would use TEE signing keys)
  const signature = await signAttestation(attestationHash, attestationPayload);

  return {
    version: '1.0',
    type: 'rofl-remote-attestation',
    
    // Core attestation data
    enclave_id: ENCLAVE_IDENTITY.enclave_id,
    app_hash: ENCLAVE_IDENTITY.app_hash,
    tee_type: ENCLAVE_IDENTITY.tee_type,
    
    // Computation proof
    input_hash: computationData.wallet_address_hash,
    output_hash: generateOutputHash(computationData),
    
    // Verification data
    attestation_hash: attestationHash,
    signature,
    
    // Metadata
    timestamp,
    nonce: attestationPayload.nonce,
    
    // Verification instructions
    verification: {
      method: 'rofl-verify',
      endpoint: 'https://verify.oasis.io/rofl',
      chain: 'sapphire-mainnet'
    }
  };
}

/**
 * Generate a cryptographically secure nonce
 */
function generateNonce() {
  return crypto.randomBytes(16).toString('hex');
}

/**
 * Generate attestation hash from payload
 */
function generateAttestationHash(payload) {
  const canonical = JSON.stringify(payload, Object.keys(payload).sort());
  return crypto.createHash('sha256').update(canonical).digest('hex');
}

/**
 * Generate output hash from computation data
 */
function generateOutputHash(data) {
  const output = {
    reputation_score: data.reputation_score,
    confidence_score: data.confidence_score
  };
  return crypto.createHash('sha256')
    .update(JSON.stringify(output))
    .digest('hex');
}

/**
 * Sign the attestation (simulated in dev, hardware-signed in production)
 * 
 * DEVELOPMENT MODE: Uses HMAC with derived key for testing
 * PRODUCTION MODE: Uses TEE's hardware-protected signing key (ROFL_SIGNING_KEY)
 */
async function signAttestation(attestationHash, payload) {
  // In production (ROFL_MODE=enclave), the ROFL runtime provides ROFL_SIGNING_KEY
  // which is derived from the TEE's hardware root of trust
  const signingKey = process.env.ROFL_SIGNING_KEY || 
    crypto.createHash('sha256')
      .update(ENCLAVE_IDENTITY.enclave_id + ENCLAVE_IDENTITY.app_hash)
      .digest('hex');

  const signature = crypto.createHmac('sha256', signingKey)
    .update(attestationHash)
    .digest('hex');

  return {
    algorithm: 'hmac-sha256',
    value: signature,
    signer: ENCLAVE_IDENTITY.enclave_id,
    mode: IS_PRODUCTION ? 'production-tee' : 'development-simulated',
    warning: IS_PRODUCTION ? null : 'DEVELOPMENT MODE: Attestation is simulated. Do not trust in production.'
  };
}

/**
 * Verify an attestation (for client-side verification)
 * 
 * @param {Object} attestation - The attestation to verify
 * @returns {Object} Verification result
 */
export async function verifyAttestation(attestation) {
  try {
    // Check required fields
    const requiredFields = [
      'enclave_id', 'app_hash', 'attestation_hash', 
      'signature', 'timestamp'
    ];
    
    for (const field of requiredFields) {
      if (!attestation[field]) {
        return {
          valid: false,
          error: `Missing required field: ${field}`
        };
      }
    }

    // Check timestamp is not too old (max 1 hour)
    const attestationTime = new Date(attestation.timestamp);
    const now = new Date();
    const ageMs = now - attestationTime;
    const maxAge = 60 * 60 * 1000; // 1 hour

    if (ageMs > maxAge) {
      return {
        valid: false,
        error: 'Attestation expired',
        age_ms: ageMs
      };
    }

    // Verify signature
    const signingKey = crypto.createHash('sha256')
      .update(attestation.enclave_id + attestation.app_hash)
      .digest('hex');

    const expectedSignature = crypto.createHmac('sha256', signingKey)
      .update(attestation.attestation_hash)
      .digest('hex');

    if (attestation.signature.value !== expectedSignature) {
      return {
        valid: false,
        error: 'Invalid signature'
      };
    }

    return {
      valid: true,
      enclave_id: attestation.enclave_id,
      app_hash: attestation.app_hash,
      tee_type: attestation.tee_type,
      timestamp: attestation.timestamp,
      verified_at: new Date().toISOString()
    };

  } catch (error) {
    return {
      valid: false,
      error: error.message
    };
  }
}

/**
 * Generate a quote request for external attestation services
 */
export function generateQuoteRequest(data) {
  return {
    enclave_id: ENCLAVE_IDENTITY.enclave_id,
    app_hash: ENCLAVE_IDENTITY.app_hash,
    user_data: crypto.createHash('sha256')
      .update(JSON.stringify(data))
      .digest('hex'),
    timestamp: new Date().toISOString()
  };
}

export { ENCLAVE_IDENTITY };
